---
title: "Differentially Gene Expression"
output:
  workflowr::wflow_html:
    toc: true
    toc_float: true
    theme: united
    highlight: textmate
editor_options:
  chunk_output_type: console
---

# Load packages
```{r message=FALSE, warning=FALSE}
library(viper)
library(aracne.networks)
library(dplyr)
library(plyr)
library(stringr)
library(Biobase)
library(EnsDb.Hsapiens.v86)
dir.create("output/DEG/",showWarnings = FALSE)
dir.create("output/expr/",showWarnings = FALSE)
```

# Define functions
```{r}
read_exp <- function(file_name) {
    expr <- read.table(file_name, header = TRUE, sep = "\t", row.names = 1,
        as.is = TRUE)
    expr[is.na(expr)] <- 0
    n_0 <- count_zeros_in_rows(as.matrix(expr))
    # Remove features with more 20% zero/missing values
    expr <- expr[n_0 >= ncol(expr)/5, ]
    # Split rownames by |
    meta <- data.frame(rownames(expr))
    colnames(meta) <- c("ENSG")
    meta$ENSG <- sub("\\..*$", "", meta$ENSG)

    geneID <- ensembldb::select(EnsDb.Hsapiens.v86, keys = meta$ENSG, keytype = "GENEID",
        columns = c("SYMBOL", "UNIPROTID", "GENEID"))
    meta$UNIPROTID <- plyr::mapvalues(meta$ENSG, from = geneID$GENEID,
        to = geneID$UNIPROTID, warn_missing = FALSE)
    meta$SYMBOL <- plyr::mapvalues(meta$ENSG, from = geneID$GENEID, to = geneID$SYMBOL,
        warn_missing = FALSE)

    # Remove duplicated indexs
    binary_unique_index <- (!duplicated(meta$SYMBOL)) & (!is.na(meta$SYMBOL) &
        (!sapply(meta$SYMBOL, function(x) startsWith(x, "ENSG"))))

    print(table(binary_unique_index))

    meta <- meta[binary_unique_index, ]

    expr <- expr[binary_unique_index, ]
    rownames(expr) <- meta$SYMBOL

    rownames(meta) <- rownames(expr)
    return(list(expr, meta))
}

calculate_log_fold_change_and_pvalue <- function(data_matrix, group, adjust_method = "BH") {
    # Check if the length of the group variable matches the number of
    # columns in the data matrix
    if (length(group) != ncol(data_matrix)) {
        stop("The length of the group variable must match the number of columns in the data matrix.")
    }
    # Ensure the group variable contains only 'normal' and 'tumor'
    if (!all(group %in% c("normal", "tumor"))) {
        stop("The group variable must only contain 'normal' and 'tumor' values.")
    }

    # Calculate the mean for each row in the tumor and normal groups
    mean_tumor <- rowMeans(data_matrix[, group == "tumor"], na.rm = TRUE)
    mean_normal <- rowMeans(data_matrix[, group == "normal"], na.rm = TRUE)

    # Calculate the fold change
    fold_change <- mean_tumor - mean_normal

    # Initialize a vector to store p-values
    p_values <- numeric(nrow(data_matrix))

    # Perform t-test for each row
    for (i in 1:nrow(data_matrix)) {
        normal_values <- data_matrix[i, group == "normal"]
        tumor_values <- data_matrix[i, group == "tumor"]
        wilcox_test_result <- wilcox.test(normal_values, tumor_values,
            paired = FALSE)
        p_values[i] <- wilcox_test_result$p.value
    }

    # Adjust the p-values
    adjusted_p_values <- p.adjust(p_values, method = adjust_method)

    # Create a data frame with fold change, p-values, and adjusted
    # p-values
    results <- data.frame(Fold_Change = fold_change, P_Value = p_values,
        Adjusted_P_Value = adjusted_p_values)
    # Return the results data frame
    return(results)
}

count_zeros_in_rows <- function(mat) {
    # Ensure the input is a matrix
    if (!is.matrix(mat)) {
        stop("Input must be a matrix.")
    }

    # Use rowSums to count zeros in each row
    zero_counts <- rowSums(mat != 0)

    return(zero_counts)
}
```

# Extract and process Gene Expression data

```{r}
df <- read.csv("data/omics_regulon_pairs.csv")
labels <- c("kirc", "kirc", "hnsc", "hnsc", "lusc", "lusc", "luad", "luad",
    "paad", "paad")
for (i in c(1, 3, 5, 7, 9)) {
    normal <- read_exp(df$RNA[i])
    expr_n <- normal[[1]]
    meta_n <- normal[[2]]

    tumor <- read_exp(df$RNA[i+1])
    expr_t <- tumor[[1]]
    meta_t <- tumor[[2]]

    common_terms <- intersect(rownames(expr_t), rownames(expr_n))

    expr_t[!is.finite(as.matrix(expr_t))] <- 0
    expr_n[!is.finite(as.matrix(expr_n))] <- 0

    expr <- cbind(expr_t[common_terms, ], expr_n[common_terms, ])

    saveRDS(expr_n[common_terms, ], paste("output/expr/count_matrix_", labels[i], "_normal.RDS",
        sep = ""))
    saveRDS(expr_t[common_terms, ], paste("output/expr/count_matrix_", labels[i], "_tumor.RDS",
        sep = ""))

    meta <- meta_n[common_terms, ]

    fc <- calculate_log_fold_change_and_pvalue(data_matrix = as.matrix(expr),
        group = c(rep("tumor", ncol(expr_t)), rep("normal", ncol(expr_n))))
    fc <- cbind(meta, fc)
    write.csv(fc, paste("output/DEG/", labels[i],
        "_fc.csv", sep = ""), row.names = F)
    fc <- fc[fc$Adjusted_P_Value < 0.05, ]
    write.csv(fc, paste("output/DEG/", labels[i],
        "_fc_0.05.csv", sep = ""), row.names = F)
}
```
