---
title: " Identify differentially Phosphorylated Sites"
output:
  workflowr::wflow_html:
    toc: true
    toc_float: true
    theme: united
    highlight: textmate
editor_options:
  chunk_output_type: console
---

# Load packages
```{r message=FALSE, warning=FALSE}
library(viper)
library(aracne.networks)
library(dplyr)
library(plyr)
library(stringr)
library(Biobase)
library(EnsDb.Hsapiens.v86)
dir.create("output/DPS/",showWarnings = FALSE)
dir.create("output/pho/",showWarnings = FALSE)
```

# Define functions
```{r}
read_phos <- function(file_name) {
    expr <- read.table(file_name, header = TRUE, sep = "\t", row.names = 1,
        as.is = TRUE)
    expr[is.na(expr)] <- 0
    n_0 <- count_zeros_in_rows(as.matrix(expr))
    # Remove features with more 20% zero/missing values
    expr <- expr[n_0 >= ncol(expr)/5,]
    # Split rownames by |
    meta <- split_and_save_df(rownames(expr))
    
    colnames(meta) <- c("ENSG", "ENSP", "S", "Seq", "Index")
    meta$ENSG <- sub("\\..*$", "", meta$ENSG)
    geneID <- ensembldb::select(EnsDb.Hsapiens.v86, keys = meta$ENSG, keytype = "GENEID",
        columns = c("SYMBOL", "UNIPROTID", "GENEID"))
    meta$UNIPROTID <- plyr::mapvalues(meta$ENSG, from = geneID$GENEID,
        to = geneID$UNIPROTID, warn_missing = FALSE)
    meta$SYMBOL <- plyr::mapvalues(meta$ENSG, from = geneID$GENEID, to = geneID$SYMBOL,
        warn_missing = FALSE)
    

    # Remove duplicated indexs
    index <- paste(meta$SYMBOL, meta$S, meta$Seq, sep = "_")
    binary_unique_index <- !duplicated(index)
    
    print(table(binary_unique_index))
    
    meta <- meta[binary_unique_index, ]

    expr <- expr[binary_unique_index, ]
    rownames(expr) <- index[binary_unique_index]
    
    rownames(meta) <- rownames(expr)
    return(list(expr, meta))
}

calculate_log_fold_change_and_pvalue <- function(data_matrix, group, adjust_method = "BH") {
  # Check if the length of the group variable matches the number of columns in the data matrix
  if (length(group) != ncol(data_matrix)) {
    stop("The length of the group variable must match the number of columns in the data matrix.")
  }
  # Ensure the group variable contains only "normal" and "tumor"
  if (!all(group %in% c("normal", "tumor"))) {
    stop("The group variable must only contain 'normal' and 'tumor' values.")
  }
  
  # Calculate the mean for each row in the tumor and normal groups
  mean_tumor <- rowMeans(data_matrix[, group == "tumor"], na.rm = TRUE)
  mean_normal <- rowMeans(data_matrix[, group == "normal"], na.rm = TRUE)
  
  # Calculate the fold change
  fold_change <- mean_tumor - mean_normal
  
  # Initialize a vector to store p-values
  p_values <- numeric(nrow(data_matrix))
  
  # Perform t-test for each row
  for (i in 1:nrow(data_matrix)) {
    normal_values <- data_matrix[i, group == "normal"]
    tumor_values <- data_matrix[i, group == "tumor"]
    wilcox_test_result <- wilcox.test(normal_values, tumor_values, paired = FALSE)
    p_values[i] <- wilcox_test_result$p.value
  }
  
  # Adjust the p-values
  adjusted_p_values <- p.adjust(p_values, method = adjust_method)
  
  # Create a data frame with fold change, p-values, and adjusted p-values
  results <- data.frame(
    Fold_Change = fold_change,
    P_Value = p_values,
    Adjusted_P_Value = adjusted_p_values
  )
  # Return the results data frame
  return(results)
}

count_zeros_in_rows <- function(mat) {
  # Ensure the input is a matrix
  if (!is.matrix(mat)) {
    stop("Input must be a matrix.")
  }
  
  # Use rowSums to count zeros in each row
  zero_counts <- rowSums(mat != 0)
  
  return(zero_counts)
}

split_and_save_df <- function(string_list) {
  # Load necessary library
  library(dplyr)
  
  # Create an empty list to store the split strings
  split_strings <- list()
  
  # Loop over each string in the list
  for (str in string_list) {
    # Split the string by the pipe character
    split_str <- strsplit(str, "\\|")[[1]]
    # Append the split string to the list
    split_strings <- append(split_strings, list(split_str))
  }
  
  # Convert the list of split strings to a dataframe
  df <- do.call(rbind, split_strings) %>% as.data.frame()
  
  return(df)
}
```

# Extract and process phosphopeptides data

```{r}
df <- read.csv("data/omics_regulon_pairs.csv")
labels <- c("kirc", "kirc", "hnsc", "hnsc", "lusc", "lusc", "luad", "luad",
    "paad", "paad")
for (i in c(1, 3, 5, 7, 9)) {
    normal <- read_phos(df$phos[i])
    expr_n <- normal[[1]]
    meta_n <- normal[[2]]

    tumor <- read_phos(df$phos[i+1])
    expr_t <- tumor[[1]]
    meta_t <- tumor[[2]]

    common_terms <- intersect(rownames(expr_t), rownames(expr_n))

    expr_t[!is.finite(as.matrix(expr_t))] <- 0
    expr_n[!is.finite(as.matrix(expr_n))] <- 0

    expr <- cbind(expr_t[common_terms, ], expr_n[common_terms, ])

    saveRDS(expr_n[common_terms, ], paste("output/pho/count_matrix_", labels[i], "_normal.RDS",
        sep = ""))
    saveRDS(expr_t[common_terms, ], paste("output/pho/count_matrix_", labels[i], "_tumor.RDS",
        sep = ""))

    meta <- meta_n[common_terms, ]

    fc <- calculate_log_fold_change_and_pvalue(data_matrix = as.matrix(expr),
        group = c(rep("tumor", ncol(expr_t)), rep("normal", ncol(expr_n))))
    fc <- cbind(meta, fc)
    write.csv(fc, paste("output/DPS/", labels[i],
        "_fc.csv", sep = ""), row.names = F)
    fc <- fc[fc$Adjusted_P_Value < 0.05, ]

    network <- read.csv("data/KSA_gold_standard.csv")
    network <- network[network$seq_15 %in% fc$Seq, ]
    unique(network$Gene.name)
    write.csv(fc[fc$Seq %in% network$seq_15, ], paste("output/DPS/", labels[i],
        "_fc_0.05_kinases.csv", sep = ""), row.names = F)
    write.csv(network, paste("output/DPS/", labels[i], "_KSA_gold_standard_0.05.csv",
        sep = ""), row.names = F)
}
```
