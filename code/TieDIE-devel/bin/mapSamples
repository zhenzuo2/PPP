#!/usr/bin/env python

###
### mapSamples: Script to map individual sample data onto a network, yeilding a sample-specific
### network
###
### Authors:
###
###		Evan Paull (epaull@soe.ucsc.edu)
###
###
### Minimum Data Inputs: 
###		
###		- sample_matrix: a gene expression matrix with normalized, median centered values per sample (column), with
###		gene names on the rows. Typically the values should be centered by the expression of a group of normal-adjacent 
###		samples.
###		- a search pathway in .sif format (geneA <interaction> geneB). Most likely a TieDIE global solution network
###
###

import os, sys, re
from optparse import OptionParser
import numpy as np
parser = OptionParser()
parser.add_option("-s","--sample_matrix",dest="sample_matrix",action="store",default=None,help="Expression Matrix for Samples")
parser.add_option("-b","--background",dest="background",action="store",default=None, help="Background Expression for Computing SD (Optional: otherwise the sample data will be used, with a permutation null model")
parser.add_option("-t","--threshold",dest="threshold",action="store",default=1.0, help="Threshold Standard Deviations to call 'Up' or down'")
parser.add_option("--min_tf_children",dest="min_tf_children",action="store",default=10, help="Minimum number of children for each transcription factor (TF) to be considered")
parser.add_option("-n","--network",dest="network",action="store",default=None,help="Full network .sif file for inferring TF regulons")
parser.add_option("-a","--activityscores",dest="activityscores",action="store_true",default=False,help="Print just the activity score matrix and quit")
(opts, args) = parser.parse_args()

sys.path.append(os.path.dirname(sys.argv[0])+'/../lib')
from distributions import Dist
from tiedie_util import *

from collections import defaultdict

def fitGeneData(activity_scores):
	"""
	Fit a normal distribution to the activity scores for each gene.

		Input
			activity_scores: scores by sample
		Output
			summary: Hash indexed by gene, with mean/sd summary statistics

	"""

	activity = {}
	for sample in activity_scores:
		for gene in activity_scores[sample]:
			if gene not in activity:
				activity[gene] = []
			activity[gene].append(activity_scores[sample][gene])

	distributions = {} 
	for gene in activity:
		distributions[gene] = Dist(activity[gene], method="gaussian")
		
	return (distributions, activity)

def getTFparents(network):
	'''
		Take a network object and index the upstream TFs for each gene
		and the type of interaction for each
		i.e. parents[gene] = (set(tf1, tf2....), {tf1:'a',tf2:'i'}}
	'''

	net = parseNet(network)
	parents = {}
	children = {}
	for source in net:
		for (int, target) in net[source]:

			a_type, edge_type = classifyInteraction(int)
			act = None

			# only transcriptional
			if edge_type != "t":
				continue

			# only activating or inactivating
			if a_type == 1:
				act = "a"
			elif a_type == 0:
				act = "i"
			else:
				continue
	
			if target not in parents:
				parents[target] = (set(), {})
			
			parents[target][0].add(source)
			parents[target][1][source] = act

			if source not in children:
				children[source] = set()

			children[source].add(target)
	
	return (parents, children)	

def getExpression(file):
	''' 
		Sample IDS should be the header line
		
		Input:
			binary_threshold: 'include expression values only if they fall above this range (abs val)
			tf_parents: 

		Returns:
			the inferred activity score (unitless) based on activity of it's downstream targets and the edge types
			for each (sum of the DE scores*link_type)
			
	'''


	# indexed by sample then by gene	
	gene_expression = {}
	 
	first = True
	sampleIDS = None
	for line in open(file, 'r'):
		parts = line.rstrip().split("\t")
		gene = parts[0]
		vals = parts[1:]
		if first:
			first = False
			sampleIDS = vals
			fixedNames = []
			for i in range(0, len(sampleIDS)):
				sample = sampleIDS[i][0:12]
				fixedNames.append(sample)

			sampleIDS = fixedNames
				
			continue

		for i in range(0,len(vals)):
			val = None
			try:
				val = float(vals[i])
			except:
				continue
			sample = sampleIDS[i]		

			###
			### Get the gene expression, indexed by samples
			###
			if sample not in gene_expression:
				gene_expression[sample] = {}
			gene_expression[sample][gene] = val

	return gene_expression

def getActivityScores(expr_data, binary_threshold, tf_genes, tf_parents): 

	# the number of counts per gene, per sample 
	counts = {}
	# store the mean scores of each gene, for each sample
	activities = {}

	for sample in expr_data:
		activities[sample] = defaultdict(float)
		counts[sample] = defaultdict(int)
		for gene in expr_data[sample]:	

			val = expr_data[sample][gene]

			if abs(val) >= binary_threshold:

				if gene not in tf_parents:
					continue

				# check, is this downstream of a TF of interest? 
				# if so, add the TF, not the gene
				parents, activation_type = tf_parents[gene]
				for parent in tf_genes.intersection(parents):
				
					act = activation_type[parent]	
					tf_act = None
					# is this TF active? 
					if act == 'a':
						tf_act = val
					elif act == 'i':	
						tf_act = -1*val

					# add the activity, and the count
					activities[sample][parent] += tf_act
					counts[sample][parent] += 1

	# convert sums to means
	for sample in activities:
		for gene in activities[sample]:
			activities[sample][gene] = activities[sample][gene]/float(counts[sample][gene])

	return activities


def getZScores(scores, stats_summary, num_tests):
	"""
	Return z-scores for activity against the supplied background
	distribution (summary statistics)	
	Input
		scores: a hash indexed by genes, values are activity scores
		stats_summary: summary statistics of the per gene distributions
	
	Returns:
		activity_z_scores: z-scores for each gene
	"""
	
	activity_z_scores = {}

	for sample in scores:
		activity_z_scores[sample] = {}
		for gene in scores[sample]:

			val = scores[sample][gene]
			
			p = stats_summary[gene].getP(val)
			z = stats_summary[gene].getZ(val)
			# correct by number of tests: i.e. the number of genes
			corrected_p = num_tests*p

			activity_z_scores[sample][gene] = (z, p, corrected_p)

	return activity_z_scores

def permuteLabels(expr_data, num_permuted_samples, by_gene=False):

	data_by_gene = {}
	all_data = []
	for sample in expr_data:
		for gene in expr_data[sample]:
			if gene not in data_by_gene:
				data_by_gene[gene] = []
			data_by_gene[gene].append(expr_data[sample][gene])
			all_data.append(expr_data[sample][gene])

	permuted = {}
	for i in range(0, num_permuted_samples):
		permuted[i] = {}
		for gene in data_by_gene:
			vals = None
			if not by_gene:
				permuted[i][gene] = random.sample(all_data,1)[0]
			else:
				vals = data_by_gene[gene]
				# sample with replacement from that gene's data
				permuted[i][gene] = random.sample(vals,1)[0]

	return permuted

def printActivityScores(z_scores, genes):

	samples = z_scores.keys()
	print "Gene\t"+"\t".join(samples)
	for gene in genes:
		printstr = gene
		for sample in samples:

			if gene not in z_scores[sample]:
				break

			score, pval, bonferroni_p = z_scores[sample][gene]	
			printstr += "\t"+str(score)

		print printstr

parents, children = getTFparents(opts.network)
# those genes which have TF children are transcriptional hubs
tf_candidates = set()
for tf in children:
	if len(children[tf]) >= int(opts.min_tf_children):
		tf_candidates.add(tf)

# get expression activity scores
sample_expr = getExpression(opts.sample_matrix)
sample_act = getActivityScores(sample_expr, 0, tf_candidates, parents)

bg_act = None
bg_stats = None
bg_activity = None
if opts.background:
	bg_expr = getExpression(opts.background)
	bg_act = getActivityScores(bg_expr, 0, tf_candidates, parents)
else:
	# permute gene labels in sample activity to get a background distribution of activity scores
	permuted_expr = permuteLabels(sample_expr, 30)	
	bg_act = getActivityScores(permuted_expr, 0, tf_candidates, parents)

bg_stats, bg_activity = fitGeneData(bg_act)
		
z_scores = getZScores(sample_act, bg_stats, len(tf_candidates))
# permute gene labels to find a background distribution for 

if opts.activityscores:
	printActivityScores(z_scores, tf_candidates)
